{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/AddressWhitelistInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\ninterface AddressWhitelistInterface {\n    function addToWhitelist(address newElement) external;\n\n    function removeFromWhitelist(address newElement) external;\n\n    function isOnWhitelist(address newElement) external view returns (bool);\n\n    function getWhitelist() external view returns (address[] memory);\n}\n"
    },
    "contracts/UmaConditionalTokensBinaryAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport { TransferHelper } from \"./libraries/TransferHelper.sol\";\n\nimport { FinderInterface } from \"./interfaces/FinderInterface.sol\";\nimport { IConditionalTokens } from \"./interfaces/IConditionalTokens.sol\";\nimport { OptimisticOracleInterface } from \"./interfaces/OptimisticOracleInterface.sol\";\nimport { AddressWhitelistInterface } from \"./interfaces/AddressWhitelistInterface.sol\";\n\n/// @title UmaConditionalTokensBinaryAdapter\n/// @notice Enables Conditional Token resolution via UMA's Optimistic Oracle\ncontract UmaConditionalTokensBinaryAdapter is ReentrancyGuard {\n    /// @notice Auth\n    mapping(address => uint256) public wards;\n\n    /// @notice Authorizes a user\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit AuthorizedUser(usr);\n    }\n\n    /// @notice Deauthorizes a user\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit DeauthorizedUser(usr);\n    }\n\n    event AuthorizedUser(address indexed usr);\n    event DeauthorizedUser(address indexed usr);\n\n    /// @notice - Authorization modifier\n    modifier auth() {\n        require(wards[msg.sender] == 1, \"Adapter/not-authorized\");\n        _;\n    }\n\n    /// @notice Conditional Tokens\n    IConditionalTokens public immutable conditionalTokenContract;\n\n    /// @notice UMA Finder address\n    address public umaFinder;\n\n    /// @notice Unique query identifier for the Optimistic Oracle\n    bytes32 public constant identifier = \"YES_OR_NO_QUERY\";\n\n    /// @notice Time period after which an authorized user can emergency resolve a condition\n    uint256 public constant emergencySafetyPeriod = 2 days;\n\n    struct QuestionData {\n        // Unix timestamp(in seconds) at which a market can be resolved\n        uint256 resolutionTime;\n        // Reward offered to a successful proposer\n        uint256 reward;\n        // Additional bond required by Optimistic oracle proposers and disputers\n        uint256 proposalBond;\n        // Flag marking the block number when a question was settled\n        uint256 settled;\n        // Early Resolution timestamp, set when an early resolution data request is sent\n        uint256 earlyResolutionTimestamp;\n        // Flag marking whether a question can be resolved early\n        bool earlyResolutionEnabled;\n        // Flag marking whether resolution data has been requested from the Oracle\n        bool resolutionDataRequested;\n        // Flag marking whether a question is resolved\n        bool resolved;\n        // Flag marking whether a question is paused\n        bool paused;\n        // ERC20 token address used for payment of rewards and fees\n        address rewardToken;\n        // Data used to resolve a condition\n        bytes ancillaryData;\n    }\n\n    /// @notice Mapping of questionID to QuestionData\n    mapping(bytes32 => QuestionData) public questions;\n\n    /*\n    ////////////////////////////////////////////////////////////////////\n                            EVENTS \n    ////////////////////////////////////////////////////////////////////\n    */\n\n    /// @notice Emitted when the UMA Finder is changed\n    event NewFinderAddress(address oldFinder, address newFinder);\n\n    /// @notice Emitted when a questionID is initialized\n    event QuestionInitialized(\n        bytes32 indexed questionID,\n        bytes ancillaryData,\n        uint256 resolutionTime,\n        address rewardToken,\n        uint256 reward,\n        uint256 proposalBond,\n        bool earlyResolutionEnabled\n    );\n\n    /// @notice Emitted when a questionID is updated\n    event QuestionUpdated(\n        bytes32 indexed questionID,\n        bytes ancillaryData,\n        uint256 resolutionTime,\n        address rewardToken,\n        uint256 reward,\n        uint256 proposalBond,\n        bool earlyResolutionEnabled\n    );\n\n    /// @notice Emitted when a question is paused by an authorized user\n    event QuestionPaused(bytes32 questionID);\n\n    /// @notice Emitted when a question is unpaused by an authorized user\n    event QuestionUnpaused(bytes32 questionID);\n\n    /// @notice Emitted when resolution data is requested from the Optimistic Oracle\n    event ResolutionDataRequested(\n        address indexed requestor,\n        uint256 indexed resolutionTimestamp,\n        bytes32 indexed questionID,\n        bytes32 identifier,\n        bytes ancillaryData,\n        address rewardToken,\n        uint256 reward,\n        uint256 proposalBond,\n        bool earlyResolution\n    );\n\n    /// @notice Emitted when a question is reset\n    event QuestionReset(bytes32 indexed questionID);\n\n    /// @notice Emitted when a question is settled\n    event QuestionSettled(bytes32 indexed questionID, int256 indexed settledPrice, bool indexed earlyResolution);\n\n    /// @notice Emitted when a question is resolved\n    event QuestionResolved(bytes32 indexed questionID, bool indexed emergencyReport);\n\n    constructor(address conditionalTokenAddress, address umaFinderAddress) {\n        wards[msg.sender] = 1;\n        emit AuthorizedUser(msg.sender);\n        conditionalTokenContract = IConditionalTokens(conditionalTokenAddress);\n        umaFinder = umaFinderAddress;\n    }\n\n    /*\n    ////////////////////////////////////////////////////////////////////\n                            PUBLIC \n    ////////////////////////////////////////////////////////////////////\n    */\n\n    /// @notice Initializes a question on the Adapter to report on\n    /// @param questionID               - The unique questionID of the question\n    /// @param ancillaryData            - Data used to resolve a question\n    /// @param resolutionTime           - Timestamp after which the Adapter can resolve a question\n    /// @param rewardToken              - ERC20 token address used for payment of rewards and fees\n    /// @param reward                   - Reward offered to a successful proposer\n    /// @param proposalBond             - Bond required to be posted by a price proposer and disputer\n    /// @param earlyResolutionEnabled   - Determines whether a question can be resolved early\n    function initializeQuestion(\n        bytes32 questionID,\n        bytes memory ancillaryData,\n        uint256 resolutionTime,\n        address rewardToken,\n        uint256 reward,\n        uint256 proposalBond,\n        bool earlyResolutionEnabled\n    ) public {\n        require(!isQuestionInitialized(questionID), \"Adapter::initializeQuestion: Question already initialized\");\n        require(resolutionTime > 0, \"Adapter::initializeQuestion: resolutionTime must be positive\");\n        require(supportedToken(rewardToken), \"Adapter::unsupported currency\");\n\n        questions[questionID] = QuestionData({\n            ancillaryData: ancillaryData,\n            resolutionTime: resolutionTime,\n            rewardToken: rewardToken,\n            reward: reward,\n            proposalBond: proposalBond,\n            earlyResolutionEnabled: earlyResolutionEnabled,\n            resolutionDataRequested: false,\n            resolved: false,\n            paused: false,\n            settled: 0,\n            earlyResolutionTimestamp: 0\n        });\n\n        emit QuestionInitialized(\n            questionID,\n            ancillaryData,\n            resolutionTime,\n            rewardToken,\n            reward,\n            proposalBond,\n            earlyResolutionEnabled\n        );\n    }\n\n    /// @notice Checks whether or not a question can start the resolution process\n    /// @param questionID - The unique questionID of the question\n    function readyToRequestResolution(bytes32 questionID) public view returns (bool) {\n        if (!isQuestionInitialized(questionID)) {\n            return false;\n        }\n        QuestionData storage questionData = questions[questionID];\n        if (questionData.resolutionDataRequested) {\n            return false;\n        }\n        if (questionData.resolved) {\n            return false;\n        }\n        if (questionData.earlyResolutionEnabled) {\n            return true;\n        }\n        return block.timestamp > questionData.resolutionTime;\n    }\n\n    /// @notice Request resolution data from the Optimistic Oracle\n    /// @param questionID - The unique questionID of the question\n    function requestResolutionData(bytes32 questionID) public nonReentrant {\n        require(\n            readyToRequestResolution(questionID),\n            \"Adapter::requestResolutionData: Question not ready to be resolved\"\n        );\n        QuestionData storage questionData = questions[questionID];\n        require(!questionData.paused, \"Adapter::requestResolutionData: Question is paused\");\n\n        // Determine if a request for resolution data is an early resolution or the standard resolution flow\n        if (questionData.earlyResolutionEnabled && block.timestamp < questionData.resolutionTime) {\n            return _earlyResolutionRequest(questionID, questionData);\n        }\n        return _standardRequest(questionID, questionData);\n    }\n\n    /// @notice Requests data from the Optimistic Oracle using the standard process\n    /// @param questionID   - The unique questionID of the question\n    /// @param questionData - The questionData of the question\n    function _standardRequest(bytes32 questionID, QuestionData storage questionData) internal {\n        // Request a price\n        _requestPrice(\n            msg.sender,\n            identifier,\n            questionData.resolutionTime,\n            questionData.ancillaryData,\n            questionData.rewardToken,\n            questionData.reward,\n            questionData.proposalBond\n        );\n\n        // Update the resolutionDataRequested flag\n        questionData.resolutionDataRequested = true;\n\n        emit ResolutionDataRequested(\n            msg.sender,\n            questionData.resolutionTime,\n            questionID,\n            identifier,\n            questionData.ancillaryData,\n            questionData.rewardToken,\n            questionData.reward,\n            questionData.proposalBond,\n            false\n        );\n    }\n\n    /// @notice Requests data from the Optimistic Oracle using early resolution\n    /// @param questionID   - The unique questionID of the question\n    /// @param questionData - The questionData of the question\n    function _earlyResolutionRequest(bytes32 questionID, QuestionData storage questionData) internal {\n        uint256 earlyResolutionTimestamp = block.timestamp;\n\n        // Request a price\n        _requestPrice(\n            msg.sender,\n            identifier,\n            earlyResolutionTimestamp,\n            questionData.ancillaryData,\n            questionData.rewardToken,\n            questionData.reward,\n            questionData.proposalBond\n        );\n\n        // Update early resolution timestamp and resolution data requested flag\n        questionData.earlyResolutionTimestamp = earlyResolutionTimestamp;\n        questionData.resolutionDataRequested = true;\n\n        emit ResolutionDataRequested(\n            msg.sender,\n            questionData.earlyResolutionTimestamp,\n            questionID,\n            identifier,\n            questionData.ancillaryData,\n            questionData.rewardToken,\n            questionData.reward,\n            questionData.proposalBond,\n            true\n        );\n    }\n\n    /// @notice Request a price from the Optimistic Oracle\n    function _requestPrice(\n        address requestor,\n        bytes32 priceIdentifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        address rewardToken,\n        uint256 reward,\n        uint256 bond\n    ) internal {\n        // Fetch the optimistic oracle\n        OptimisticOracleInterface optimisticOracle = getOptimisticOracle();\n\n        // If non-zero reward, pay for the price request by transferring rewardToken from the requestor\n        if (reward > 0) {\n            TransferHelper.safeTransferFrom(rewardToken, requestor, address(this), reward);\n\n            // Approve the OO to transfer the reward token from the Adapter\n            if (IERC20(rewardToken).allowance(address(this), address(optimisticOracle)) < type(uint256).max) {\n                TransferHelper.safeApprove(rewardToken, address(optimisticOracle), type(uint256).max);\n            }\n        }\n\n        // Send a price request to the Optimistic oracle\n        optimisticOracle.requestPrice(priceIdentifier, timestamp, ancillaryData, IERC20(rewardToken), reward);\n\n        // Update the proposal bond on the Optimistic oracle if necessary\n        if (bond > 0) {\n            optimisticOracle.setBond(priceIdentifier, timestamp, ancillaryData, bond);\n        }\n    }\n\n    /// @notice Checks whether a questionID is ready to be settled\n    /// @param questionID - The unique questionID of the question\n    function readyToSettle(bytes32 questionID) public view returns (bool) {\n        if (!isQuestionInitialized(questionID)) {\n            return false;\n        }\n        QuestionData storage questionData = questions[questionID];\n        // Ensure resolution data has been requested for question\n        if (questionData.resolutionDataRequested == false) {\n            return false;\n        }\n        // Ensure question has not been resolved\n        if (questionData.resolved == true) {\n            return false;\n        }\n        // Ensure question has not been settled\n        if (questionData.settled != 0) {\n            return false;\n        }\n\n        OptimisticOracleInterface optimisticOracle = getOptimisticOracle();\n\n        return\n            optimisticOracle.hasPrice(\n                address(this),\n                identifier,\n                _getTimestamp(questionData),\n                questionData.ancillaryData\n            );\n    }\n\n    /// @notice Settle/finalize the resolution data of a question\n    /// @notice If the OO returns the ignore price, this method resets the question, allowing new price requests\n    /// @param questionID - The unique questionID of the question\n    function settle(bytes32 questionID) public {\n        require(readyToSettle(questionID), \"Adapter::settle: questionID is not ready to be settled\");\n        QuestionData storage questionData = questions[questionID];\n        require(!questionData.paused, \"Adapter::settle: Question is paused\");\n\n        if (questionData.earlyResolutionEnabled && questionData.earlyResolutionTimestamp > 0) {\n            return _earlySettle(questionID, questionData);\n        }\n        return _standardSettle(questionID, questionData);\n    }\n\n    function _standardSettle(bytes32 questionID, QuestionData storage questionData) internal {\n        OptimisticOracleInterface optimisticOracle = getOptimisticOracle();\n\n        int256 proposedPrice = optimisticOracle\n            .getRequest(address(this), identifier, questionData.resolutionTime, questionData.ancillaryData)\n            .proposedPrice;\n\n        // NOTE: If the proposed price is the ignore price, reset the question, allowing new resolution requests\n        if (proposedPrice == ignorePrice()) {\n            _resetQuestion(questionID, questionData);\n            return;\n        }\n\n        // Set the settled block number\n        questionData.settled = block.number;\n\n        // Settle the price\n        int256 settledPrice = optimisticOracle.settleAndGetPrice(\n            identifier,\n            questionData.resolutionTime,\n            questionData.ancillaryData\n        );\n        emit QuestionSettled(questionID, settledPrice, false);\n    }\n\n    function _earlySettle(bytes32 questionID, QuestionData storage questionData) internal {\n        OptimisticOracleInterface optimisticOracle = getOptimisticOracle();\n\n        // Fetch the current proposed price from the OO\n        int256 proposedPrice = optimisticOracle\n            .getRequest(address(this), identifier, questionData.earlyResolutionTimestamp, questionData.ancillaryData)\n            .proposedPrice;\n\n        // NOTE: If the proposed price is the ignore price, reset the question, allowing new resolution requests\n        if (proposedPrice == ignorePrice()) {\n            _resetQuestion(questionID, questionData);\n            return;\n        }\n\n        // Set the settled block number\n        questionData.settled = block.number;\n\n        // Settle the price\n        int256 settledPrice = optimisticOracle.settleAndGetPrice(\n            identifier,\n            questionData.earlyResolutionTimestamp,\n            questionData.ancillaryData\n        );\n        emit QuestionSettled(questionID, settledPrice, true);\n    }\n\n    function _resetQuestion(bytes32 questionID, QuestionData storage questionData) internal {\n        questionData.earlyResolutionTimestamp = 0;\n        questionData.resolutionDataRequested = false;\n        emit QuestionReset(questionID);\n    }\n\n    function _getTimestamp(QuestionData storage questionData) internal view returns (uint256) {\n        if (questionData.earlyResolutionEnabled && questionData.earlyResolutionTimestamp > 0) {\n            return questionData.earlyResolutionTimestamp;\n        }\n        return questionData.resolutionTime;\n    }\n\n    /// @notice Retrieves the expected payout of a settled question\n    /// @param questionID - The unique questionID of the question\n    function getExpectedPayouts(bytes32 questionID) public view returns (uint256[] memory) {\n        require(isQuestionInitialized(questionID), \"Adapter::getExpectedPayouts: questionID is not initialized\");\n        QuestionData storage questionData = questions[questionID];\n\n        require(\n            questionData.resolutionDataRequested,\n            \"Adapter::getExpectedPayouts: resolutionData has not been requested\"\n        );\n        require(!questionData.resolved, \"Adapter::getExpectedPayouts: questionID is already resolved\");\n        require(questionData.settled > 0, \"Adapter::getExpectedPayouts: questionID is not settled\");\n        require(!questionData.paused, \"Adapter::getExpectedPayouts: Question is paused\");\n\n        // Fetches resolution data from OO\n        int256 resolutionData = getExpectedResolutionData(questionData);\n\n        // Payouts: [YES, NO]\n        uint256[] memory payouts = new uint256[](2);\n\n        // Valid prices are 0, 0.5 and 1\n        require(\n            resolutionData == 0 || resolutionData == 0.5 ether || resolutionData == 1 ether,\n            \"Adapter::reportPayouts: Invalid resolution data\"\n        );\n\n        if (resolutionData == 0) {\n            // NO: Report [Yes, No] as [0, 1]\n            payouts[0] = 0;\n            payouts[1] = 1;\n        } else if (resolutionData == 0.5 ether) {\n            // UNKNOWN: Report [Yes, No] as [1, 1], 50/50\n            payouts[0] = 1;\n            payouts[1] = 1;\n        } else {\n            // YES: Report [Yes, No] as [1, 0]\n            payouts[0] = 1;\n            payouts[1] = 0;\n        }\n        return payouts;\n    }\n\n    function getExpectedResolutionData(QuestionData storage questionData) internal view returns (int256) {\n        return\n            getOptimisticOracle()\n                .getRequest(address(this), identifier, _getTimestamp(questionData), questionData.ancillaryData)\n                .resolvedPrice;\n    }\n\n    /// @notice Resolves a question\n    /// @param questionID - The unique questionID of the question\n    function reportPayouts(bytes32 questionID) public {\n        QuestionData storage questionData = questions[questionID];\n\n        // Payouts: [YES, NO]\n        // getExpectedPayouts verifies that questionID is settled and can be resolved\n        uint256[] memory payouts = getExpectedPayouts(questionID);\n\n        require(\n            block.number > questionData.settled,\n            \"Adapter::reportPayouts: Attempting to settle and reportPayouts in the same block\"\n        );\n\n        questionData.resolved = true;\n        conditionalTokenContract.reportPayouts(questionID, payouts);\n        emit QuestionResolved(questionID, false);\n    }\n\n    /*\n    ////////////////////////////////////////////////////////////////////\n                            AUTHORIZED ONLY FUNCTIONS \n    ////////////////////////////////////////////////////////////////////\n    */\n\n    /// @notice Allows an authorized user to update a question\n    /// @param questionID             - The unique questionID of the question\n    /// @param ancillaryData          - Data used to resolve a question\n    /// @param resolutionTime         - Timestamp after which the Adapter can resolve a question\n    /// @param rewardToken            - ERC20 token address used for payment of rewards and fees\n    /// @param reward                 - Reward offered to a successful proposer\n    /// @param proposalBond           - Bond required to be posted by a price proposer and disputer\n    /// @param earlyResolutionEnabled - Determines whether a question can be resolved early\n    function updateQuestion(\n        bytes32 questionID,\n        bytes memory ancillaryData,\n        uint256 resolutionTime,\n        address rewardToken,\n        uint256 reward,\n        uint256 proposalBond,\n        bool earlyResolutionEnabled\n    ) external auth {\n        require(isQuestionInitialized(questionID), \"Adapter::updateQuestion: Question not initialized\");\n        require(resolutionTime > 0, \"Adapter::updateQuestion: resolutionTime must be positive\");\n        require(supportedToken(rewardToken), \"Adapter::unsupported currency\");\n        require(questions[questionID].settled == 0, \"Adapter::updateQuestion: Question is already settled\");\n\n        questions[questionID] = QuestionData({\n            ancillaryData: ancillaryData,\n            resolutionTime: resolutionTime,\n            rewardToken: rewardToken,\n            reward: reward,\n            proposalBond: proposalBond,\n            earlyResolutionEnabled: earlyResolutionEnabled,\n            resolutionDataRequested: false,\n            resolved: false,\n            paused: false,\n            settled: 0,\n            earlyResolutionTimestamp: 0\n        });\n\n        emit QuestionUpdated(\n            questionID,\n            ancillaryData,\n            resolutionTime,\n            rewardToken,\n            reward,\n            proposalBond,\n            earlyResolutionEnabled\n        );\n    }\n\n    /// @notice Allows an authorized user to report payouts in an emergency\n    /// @param questionID - The unique questionID of the question\n    function emergencyReportPayouts(bytes32 questionID, uint256[] calldata payouts) external auth {\n        require(isQuestionInitialized(questionID), \"Adapter::emergencyReportPayouts: questionID is not initialized\");\n\n        require(\n            block.timestamp > questions[questionID].resolutionTime + emergencySafetyPeriod,\n            \"Adapter::emergencyReportPayouts: safety period has not passed\"\n        );\n\n        require(payouts.length == 2, \"Adapter::emergencyReportPayouts: payouts must be binary\");\n\n        QuestionData storage questionData = questions[questionID];\n\n        questionData.resolved = true;\n        conditionalTokenContract.reportPayouts(questionID, payouts);\n        emit QuestionResolved(questionID, true);\n    }\n\n    /// @notice Allows an authorized user to pause market resolution in an emergency\n    /// @param questionID - The unique questionID of the question\n    function pauseQuestion(bytes32 questionID) external auth {\n        require(isQuestionInitialized(questionID), \"Adapter::pauseQuestion: questionID is not initialized\");\n        QuestionData storage questionData = questions[questionID];\n\n        questionData.paused = true;\n        emit QuestionPaused(questionID);\n    }\n\n    /// @notice Allows an authorized user to unpause market resolution in an emergency\n    /// @param questionID - The unique questionID of the question\n    function unPauseQuestion(bytes32 questionID) external auth {\n        require(isQuestionInitialized(questionID), \"Adapter::unPauseQuestion: questionID is not initialized\");\n        QuestionData storage questionData = questions[questionID];\n        questionData.paused = false;\n        emit QuestionUnpaused(questionID);\n    }\n\n    /// @notice Allows an authorized user to update the UMA Finder address\n    /// @param newFinderAddress - The new finder address\n    function setFinderAddress(address newFinderAddress) external auth {\n        emit NewFinderAddress(umaFinder, newFinderAddress);\n        umaFinder = newFinderAddress;\n    }\n\n    /*\n    ////////////////////////////////////////////////////////////////////\n                            UTILITY FUNCTIONS \n    ////////////////////////////////////////////////////////////////////\n    */\n\n    /// @notice Utility function that atomically prepares a question on the Conditional Tokens contract\n    ///         and initializes it on the Adapter\n    /// @dev Prepares the condition using the Adapter as the oracle and a fixed outcomeSlotCount\n    /// @param questionID               - The unique questionID of the question\n    /// @param ancillaryData            - Data used to resolve a question\n    /// @param resolutionTime           - Timestamp after which the Adapter can resolve a question\n    /// @param rewardToken              - ERC20 token address used for payment of rewards and fees\n    /// @param reward                   - Reward offered to a successful proposer\n    /// @param proposalBond             - Bond required to be posted by a price proposer and disputer\n    /// @param earlyResolutionEnabled   - Determines whether a question can be resolved early\n    function prepareAndInitialize(\n        bytes32 questionID,\n        bytes memory ancillaryData,\n        uint256 resolutionTime,\n        address rewardToken,\n        uint256 reward,\n        uint256 proposalBond,\n        bool earlyResolutionEnabled\n    ) public {\n        conditionalTokenContract.prepareCondition(address(this), questionID, 2);\n        initializeQuestion(\n            questionID,\n            ancillaryData,\n            resolutionTime,\n            rewardToken,\n            reward,\n            proposalBond,\n            earlyResolutionEnabled\n        );\n    }\n\n    /// @notice Utility function that verifies if a question is initialized\n    /// @param questionID - The unique questionID\n    function isQuestionInitialized(bytes32 questionID) public view returns (bool) {\n        return questions[questionID].resolutionTime > 0;\n    }\n\n    /// @notice Price that indicates that the OO does not have a valid price yet\n    function ignorePrice() public pure returns (int256) {\n        return type(int256).min;\n    }\n\n    function getOptimisticOracleAddress() internal view returns (address) {\n        return FinderInterface(umaFinder).getImplementationAddress(\"OptimisticOracle\");\n    }\n\n    function getOptimisticOracle() internal view returns (OptimisticOracleInterface) {\n        return OptimisticOracleInterface(getOptimisticOracleAddress());\n    }\n\n    function getCollateralWhitelistAddress() internal view returns (address) {\n        return FinderInterface(umaFinder).getImplementationAddress(\"CollateralWhitelist\");\n    }\n\n    function supportedToken(address token) internal view returns (bool) {\n        return AddressWhitelistInterface(getCollateralWhitelistAddress()).isOnWhitelist(token);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title TransferHelper\n/// @author Uniswap: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/TransferHelper.sol\nlibrary TransferHelper {\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @notice Errors with 'STF' if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"STF\");\n    }\n\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with ST if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"ST\");\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev Errors with 'SA' if transfer fails\n    /// @param token The contract address of the token to be approved\n    /// @param to The target of the approval\n    /// @param value The amount of the given token the target will be allowed to spend\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"SA\");\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Fails with `STE`\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"STE\");\n    }\n}\n"
    },
    "contracts/interfaces/FinderInterface.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.0;\n\n/**\n * @title Provides addresses of the live contracts implementing certain interfaces.\n * @dev Examples are the Oracle or Store interfaces.\n */\ninterface FinderInterface {\n    /**\n     * @notice Updates the address of the contract that implements `interfaceName`.\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n     * @param implementationAddress address of the deployed contract that implements the interface.\n     */\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n\n    /**\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\n     * @param interfaceName queried interface.\n     * @return implementationAddress address of the deployed contract that implements the interface.\n     */\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IConditionalTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IConditionalTokens {\n    /// @dev Emitted upon the successful preparation of a condition.\n    /// @param conditionId The condition's ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\n    event ConditionPreparation(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount\n    );\n\n    event ConditionResolution(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount,\n        uint256[] payoutNumerators\n    );\n\n    /// @dev Emitted when a position is successfully split.\n    event PositionSplit(\n        address indexed stakeholder,\n        IERC20 collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n    /// @dev Emitted when positions are successfully merged.\n    event PositionsMerge(\n        address indexed stakeholder,\n        IERC20 collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 indexed conditionId,\n        uint256[] partition,\n        uint256 amount\n    );\n    event PayoutRedemption(\n        address indexed redeemer,\n        IERC20 indexed collateralToken,\n        bytes32 indexed parentCollectionId,\n        bytes32 conditionId,\n        uint256[] indexSets,\n        uint256 payout\n    );\n\n    /// Mapping key is an condition ID. Value represents numerators of the payout vector associated with the condition. This array is initialized with a length equal to the outcome slot count. E.g. Condition with 3 outcomes [A, B, C] and two of those correct [0.5, 0.5, 0]. In Ethereum there are no decimal values, so here, 0.5 is represented by fractions like 1/2 == 0.5. That's why we need numerator and denominator values. Payout numerators are also used as a check of initialization. If the numerators array is empty (has length zero), the condition was not created/prepared. See getOutcomeSlotCount.\n    function payoutNumerators(bytes32) external returns (uint256[] memory);\n\n    /// Denominator is also used for checking if the condition has been resolved. If the denominator is non-zero, then the condition has been resolved.\n    function payoutDenominator(bytes32) external returns (uint256);\n\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\n    function prepareCondition(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) external;\n\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\n    /// @param questionId The question ID the oracle is answering for\n    /// @param payouts The oracle's answer\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts) external;\n\n    /// @dev This function splits a position. If splitting from the collateral, this contract will attempt to transfer `amount` collateral from the message sender to itself. Otherwise, this contract will burn `amount` stake held by the message sender in the position being split worth of EIP 1155 tokens. Regardless, if successful, `amount` stake will be minted in the split target positions. If any of the transfers, mints, or burns fail, the transaction will revert. The transaction will also revert if the given partition is trivial, invalid, or refers to more slots than the condition is prepared with.\n    /// @param collateralToken The address of the positions' backing collateral token.\n    /// @param parentCollectionId The ID of the outcome collections common to the position being split and the split target positions. May be null, in which only the collateral is shared.\n    /// @param conditionId The ID of the condition to split on.\n    /// @param partition An array of disjoint index sets representing a nontrivial partition of the outcome slots of the given condition. E.g. A|B and C but not A|B and B|C (is not disjoint). Each element's a number which, together with the condition, represents the outcome collection. E.g. 0b110 is A|B, 0b010 is B, etc.\n    /// @param amount The amount of collateral or stake to split.\n    function splitPosition(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external;\n\n    function mergePositions(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata partition,\n        uint256 amount\n    ) external;\n\n    function redeemPositions(\n        IERC20 collateralToken,\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256[] calldata indexSets\n    ) external;\n\n    /// @dev Gets the outcome slot count of a condition.\n    /// @param conditionId ID of the condition.\n    /// @return Number of outcome slots associated with a condition, or zero if condition has not been prepared yet.\n    function getOutcomeSlotCount(bytes32 conditionId) external view returns (uint256);\n\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\n    function getConditionId(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) external pure returns (bytes32);\n\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\n    function getCollectionId(\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256 indexSet\n    ) external view returns (bytes32);\n\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\n    /// @param collateralToken Collateral token which backs the position.\n    /// @param collectionId ID of the outcome collection associated with this position.\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId) external pure returns (uint256);\n}\n"
    },
    "contracts/interfaces/OptimisticOracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface OptimisticOracleInterface {\n    // Struct representing a price request.\n    struct Request {\n        address proposer; // Address of the proposer.\n        address disputer; // Address of the disputer.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        bool settled; // True if the request is settled.\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n        int256 proposedPrice; // Price that the proposer submitted.\n        int256 resolvedPrice; // Price resolved once the request is settled.\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n        uint256 customLiveness; // Custom liveness value set by the requester.\n    }\n\n    /**\n     * @notice Requests a new price.\n     * @param identifier price identifier being requested.\n     * @param timestamp timestamp of the price being requested.\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n     *               which could make sense if the contract requests and proposes the value in the same call or\n     *               provides its own reward system.\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n     * This can be changed with a subsequent call to setBond().\n     */\n    function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external returns (uint256 totalBond);\n\n    /**\n     * @notice Set the proposal bond associated with a price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @param bond custom bond amount to set.\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n     * changed again with a subsequent call to setBond().\n     */\n    function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external returns (uint256 totalBond);\n\n    /**\n     * @notice Gets the current data structure containing all information about a price request.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return the Request data structure.\n     */\n    function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external view returns (Request memory);\n\n    /**\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n     * the returned bonds as well as additional rewards.\n     */\n    function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external returns (uint256 payout);\n\n    /**\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n     * hasn't been settled.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return resolved price.\n     */\n    function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external returns (int256);\n\n    /**\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n     * @param requester sender of the initial price request.\n     * @param identifier price identifier to identify the existing request.\n     * @param timestamp timestamp to identify the existing request.\n     * @param ancillaryData ancillary data of the price being requested.\n     * @return true if price has resolved or settled, false otherwise.\n     */\n    function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/test/TestERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestERC20 is ERC20 {\n    // solhint-disable-next-line no-empty-blocks\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n}\n"
    },
    "contracts/mocks/CTHelpers.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\n\npragma solidity 0.8.0;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title CTHelpers\n * @author Gnosis (https://gnosis.io)\n * @notice Library copied from https://github.com/gnosis/conditional-tokens-contracts to be compiled under solc 0.7.4\n * see: https://github.com/gnosis/conditional-tokens-contracts/blob/4afa2fe/contracts/CTHelpers.sol\n */\nlibrary CTHelpers {\n    /// @dev Constructs a condition ID from an oracle, a question ID, and the outcome slot count for the question.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\n    function getConditionId(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount));\n    }\n\n    uint256 public constant P = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    uint256 public constant B = 3;\n\n    function sqrt(uint256 x) private pure returns (uint256 y) {\n        uint256 p = P;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // add chain generated via https://crypto.stackexchange.com/q/27179/71252\n            // and transformed to the following program:\n\n            // x=1; y=x+x; z=y+y; z=z+z; y=y+z; x=x+y; y=y+x; z=y+y; t=z+z; t=z+t; t=t+t;\n            // t=t+t; z=z+t; x=x+z; z=x+x; z=z+z; y=y+z; z=y+y; z=z+z; z=z+z; z=y+z; x=x+z;\n            // z=x+x; z=z+z; z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; z=y+y; t=z+z;\n            // t=t+t; t=t+t; z=z+t; x=x+z; y=y+x; z=y+y; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\n            // z=x+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; t=z+z; t=t+t; t=z+t; t=y+t; t=t+t;\n            // t=t+t; t=t+t; t=t+t; z=z+t; x=x+z; z=x+x; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z;\n            // t=z+z; t=z+t; w=t+t; w=w+w; w=w+w; w=w+w; w=w+w; t=t+w; z=z+t; x=x+z; y=y+x;\n            // z=y+y; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; z=z+z; y=y+z; z=y+y;\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; x=x+z; y=y+x; x=x+y; y=y+x; z=y+y; z=z+z;\n            // z=y+z; x=x+z; z=x+x; z=x+z; y=y+z; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; z=y+z;\n            // z=z+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x; t=z+z; t=t+t; t=z+t;\n            // t=x+t; t=t+t; t=t+t; t=t+t; t=t+t; z=z+t; y=y+z; x=x+y; y=y+x; x=x+y; z=x+x;\n            // z=x+z; z=z+z; z=z+z; z=z+z; z=x+z; y=y+z; z=y+y; z=y+z; z=z+z; x=x+z; z=x+x;\n            // z=x+z; y=y+z; x=x+y; z=x+x; z=z+z; y=y+z; x=x+y; z=x+x; y=y+z; x=x+y; y=y+x;\n            // z=y+y; z=y+z; x=x+z; y=y+x; z=y+y; z=y+z; z=z+z; z=z+z; x=x+z; z=x+x; z=z+z;\n            // z=z+z; z=x+z; y=y+z; x=x+y; z=x+x; t=x+z; t=t+t; t=t+t; z=z+t; y=y+z; z=y+y;\n            // x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; y=y+x; z=y+y; t=y+z; z=y+t; z=z+z; z=z+z;\n            // z=t+z; x=x+z; y=y+x; x=x+y; y=y+x; x=x+y; z=x+x; z=x+z; y=y+z; x=x+y; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x; x=x+x;\n            // x=x+x; x=x+x; x=x+x; x=x+x; res=y+x\n            // res == (P + 1) // 4\n\n            y := mulmod(x, x, p)\n            {\n                let z := mulmod(y, y, p)\n                z := mulmod(z, z, p)\n                y := mulmod(y, z, p)\n                x := mulmod(x, y, p)\n                y := mulmod(y, x, p)\n                z := mulmod(y, y, p)\n                {\n                    let t := mulmod(z, z, p)\n                    t := mulmod(z, t, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    z := mulmod(z, t, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(z, z, p)\n                    y := mulmod(y, z, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(y, z, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(x, z, p)\n                    y := mulmod(y, z, p)\n                    x := mulmod(x, y, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(z, z, p)\n                    y := mulmod(y, z, p)\n                    z := mulmod(y, y, p)\n                    t := mulmod(z, z, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    z := mulmod(z, t, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(x, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(x, z, p)\n                    y := mulmod(y, z, p)\n                    z := mulmod(y, y, p)\n                    t := mulmod(z, z, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(z, t, p)\n                    t := mulmod(y, t, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    z := mulmod(z, t, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(x, z, p)\n                    y := mulmod(y, z, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(y, z, p)\n                    z := mulmod(z, z, p)\n                    t := mulmod(z, z, p)\n                    t := mulmod(z, t, p)\n                    {\n                        let w := mulmod(t, t, p)\n                        w := mulmod(w, w, p)\n                        w := mulmod(w, w, p)\n                        w := mulmod(w, w, p)\n                        w := mulmod(w, w, p)\n                        t := mulmod(t, w, p)\n                    }\n                    z := mulmod(z, t, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    x := mulmod(x, y, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(x, z, p)\n                    z := mulmod(z, z, p)\n                    y := mulmod(y, z, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(z, z, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(y, z, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(y, z, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(x, z, p)\n                    y := mulmod(y, z, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(y, z, p)\n                    z := mulmod(z, z, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(y, z, p)\n                    z := mulmod(z, z, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    t := mulmod(z, z, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(z, t, p)\n                    t := mulmod(x, t, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    z := mulmod(z, t, p)\n                    y := mulmod(y, z, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    x := mulmod(x, y, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(x, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(x, z, p)\n                    y := mulmod(y, z, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(y, z, p)\n                    z := mulmod(z, z, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(x, z, p)\n                    y := mulmod(y, z, p)\n                    x := mulmod(x, y, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(z, z, p)\n                    y := mulmod(y, z, p)\n                    x := mulmod(x, y, p)\n                    z := mulmod(x, x, p)\n                    y := mulmod(y, z, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(y, z, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    z := mulmod(y, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    x := mulmod(x, z, p)\n                    z := mulmod(x, x, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(x, z, p)\n                    y := mulmod(y, z, p)\n                    x := mulmod(x, y, p)\n                    z := mulmod(x, x, p)\n                    t := mulmod(x, z, p)\n                    t := mulmod(t, t, p)\n                    t := mulmod(t, t, p)\n                    z := mulmod(z, t, p)\n                    y := mulmod(y, z, p)\n                    z := mulmod(y, y, p)\n                    x := mulmod(x, z, p)\n                    y := mulmod(y, x, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    x := mulmod(x, y, p)\n                    y := mulmod(y, x, p)\n                    z := mulmod(y, y, p)\n                    t := mulmod(y, z, p)\n                    z := mulmod(y, t, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(z, z, p)\n                    z := mulmod(t, z, p)\n                }\n                x := mulmod(x, z, p)\n                y := mulmod(y, x, p)\n                x := mulmod(x, y, p)\n                y := mulmod(y, x, p)\n                x := mulmod(x, y, p)\n                z := mulmod(x, x, p)\n                z := mulmod(x, z, p)\n                y := mulmod(y, z, p)\n            }\n            x := mulmod(x, y, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            x := mulmod(x, x, p)\n            y := mulmod(y, x, p)\n        }\n    }\n\n    /// @dev Constructs an outcome collection ID from a parent collection and an outcome collection.\n    /// @param parentCollectionId Collection ID of the parent outcome collection, or bytes32(0) if there's no parent.\n    /// @param conditionId Condition ID of the outcome collection to combine with the parent outcome collection.\n    /// @param indexSet Index set of the outcome collection to combine with the parent outcome collection.\n    function getCollectionId(\n        bytes32 parentCollectionId,\n        bytes32 conditionId,\n        uint256 indexSet\n    ) internal view returns (bytes32) {\n        uint256 x1 = uint256(keccak256(abi.encodePacked(conditionId, indexSet)));\n        bool odd = x1 >> 255 != 0;\n        uint256 y1;\n        uint256 yy;\n        do {\n            x1 = addmod(x1, 1, P);\n            yy = addmod(mulmod(x1, mulmod(x1, x1, P), P), B, P);\n            y1 = sqrt(yy);\n        } while (mulmod(y1, y1, P) != yy);\n        if ((odd && y1 % 2 == 0) || (!odd && y1 % 2 == 1)) y1 = P - y1;\n\n        uint256 x2 = uint256(parentCollectionId);\n        if (x2 != 0) {\n            odd = x2 >> 254 != 0;\n            x2 = (x2 << 2) >> 2;\n            yy = addmod(mulmod(x2, mulmod(x2, x2, P), P), B, P);\n            uint256 y2 = sqrt(yy);\n            if ((odd && y2 % 2 == 0) || (!odd && y2 % 2 == 1)) y2 = P - y2;\n            require(mulmod(y2, y2, P) == yy, \"invalid parent collection ID\");\n\n            (bool success, bytes memory ret) = address(6).staticcall(abi.encode(x1, y1, x2, y2));\n            require(success, \"ecadd failed\");\n            (x1, y1) = abi.decode(ret, (uint256, uint256));\n        }\n\n        if (y1 % 2 == 1) x1 ^= 1 << 254;\n\n        return bytes32(x1);\n    }\n\n    /// @dev Constructs a position ID from a collateral token and an outcome collection. These IDs are used as the ERC-1155 ID for this contract.\n    /// @param collateralToken Collateral token which backs the position.\n    /// @param collectionId ID of the outcome collection associated with this position.\n    function getPositionId(IERC20 collateralToken, bytes32 collectionId) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(collateralToken, collectionId)));\n    }\n}\n"
    },
    "contracts/mocks/MockConditionalTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { CTHelpers } from \"./CTHelpers.sol\";\n\ncontract MockConditionalTokens {\n    using SafeMath for uint256;\n\n    /// @dev Emitted upon the successful preparation of a condition.\n    /// @param conditionId The condition's ID. This ID may be derived from the other three parameters via ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\n    event ConditionPreparation(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount\n    );\n\n    event ConditionResolution(\n        bytes32 indexed conditionId,\n        address indexed oracle,\n        bytes32 indexed questionId,\n        uint256 outcomeSlotCount,\n        uint256[] payoutNumerators\n    );\n\n    /// Mapping key is an condition ID. Value represents numerators of the payout vector associated with the condition. This array is initialized with a length equal to the outcome slot count. E.g. Condition with 3 outcomes [A, B, C] and two of those correct [0.5, 0.5, 0]. In Ethereum there are no decimal values, so here, 0.5 is represented by fractions like 1/2 == 0.5. That's why we need numerator and denominator values. Payout numerators are also used as a check of initialization. If the numerators array is empty (has length zero), the condition was not created/prepared. See getOutcomeSlotCount.\n    mapping(bytes32 => uint256[]) public payoutNumerators;\n    /// Denominator is also used for checking if the condition has been resolved. If the denominator is non-zero, then the condition has been resolved.\n    mapping(bytes32 => uint256) public payoutDenominator;\n\n    function getConditionId(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) external pure returns (bytes32) {\n        return CTHelpers.getConditionId(oracle, questionId, outcomeSlotCount);\n    }\n\n    /// @dev This function prepares a condition by initializing a payout vector associated with the condition.\n    /// @param oracle The account assigned to report the result for the prepared condition.\n    /// @param questionId An identifier for the question to be answered by the oracle.\n    /// @param outcomeSlotCount The number of outcome slots which should be used for this condition. Must not exceed 256.\n    function prepareCondition(\n        address oracle,\n        bytes32 questionId,\n        uint256 outcomeSlotCount\n    ) external {\n        // Limit of 256 because we use a partition array that is a number of 256 bits.\n        require(outcomeSlotCount <= 256, \"too many outcome slots\");\n        require(outcomeSlotCount > 1, \"there should be more than one outcome slot\");\n        bytes32 conditionId = CTHelpers.getConditionId(oracle, questionId, outcomeSlotCount);\n        require(payoutNumerators[conditionId].length == 0, \"condition already prepared\");\n        payoutNumerators[conditionId] = new uint256[](outcomeSlotCount);\n        emit ConditionPreparation(conditionId, oracle, questionId, outcomeSlotCount);\n    }\n\n    /// @dev Called by the oracle for reporting results of conditions. Will set the payout vector for the condition with the ID ``keccak256(abi.encodePacked(oracle, questionId, outcomeSlotCount))``, where oracle is the message sender, questionId is one of the parameters of this function, and outcomeSlotCount is the length of the payouts parameter, which contains the payoutNumerators for each outcome slot of the condition.\n    /// @param questionId The question ID the oracle is answering for\n    /// @param payouts The oracle's answer\n    function reportPayouts(bytes32 questionId, uint256[] calldata payouts) external {\n        uint256 outcomeSlotCount = payouts.length;\n        require(outcomeSlotCount > 1, \"there should be more than one outcome slot\");\n        // IMPORTANT, the oracle is enforced to be the sender because it's part of the hash.\n        bytes32 conditionId = CTHelpers.getConditionId(msg.sender, questionId, outcomeSlotCount);\n        require(payoutNumerators[conditionId].length == outcomeSlotCount, \"condition not prepared or found\");\n        require(payoutDenominator[conditionId] == 0, \"payout denominator already set\");\n\n        uint256 den = 0;\n        for (uint256 i = 0; i < outcomeSlotCount; i++) {\n            uint256 num = payouts[i];\n            den = den.add(num);\n\n            require(payoutNumerators[conditionId][i] == 0, \"payout numerator already set\");\n            payoutNumerators[conditionId][i] = num;\n        }\n        require(den > 0, \"payout is all zeroes\");\n        payoutDenominator[conditionId] = den;\n        emit ConditionResolution(conditionId, msg.sender, questionId, outcomeSlotCount, payoutNumerators[conditionId]);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}